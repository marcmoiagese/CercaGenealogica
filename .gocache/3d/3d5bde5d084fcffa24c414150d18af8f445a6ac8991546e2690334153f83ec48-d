//line /home/marc/codi/CercaGenealogica3/core/webserver.go:1:1
// core/webserver.go
package core

import (
	"net/http"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/marcmoiagese/CercaGenealogica/cnf"
)

var blockedUserAgents = []string{
	"wget", "curl", "PostmanRuntime", "python-requests", "bot", "scrubby", "Yandex",
}

var allowedFiles = map[string]bool{
	"css/estils.css":          true,
	"css/menu.css":            true,
	"css/perfil-dropdown.css": true,
	"css/login-modal.css":     true,
	"css/registre.css":        true,
	"css/regenerar-token.css": true,
	"js/login-modal.js":       true,
	"js/perfil-dropdown.js":   true,
	"js/idioma.js":            true,
	"img/logo.png":            true,
	"js/menu.js":              true,
}

// rateLimiter – Usarem sync.Map per compartir entre goroutines
// Implementació de Token Bucket per limitar per IP/ruta amb burst
type tokenBucket struct {
	mu         sync.Mutex
	tokens     float64
	capacity   float64
	fillRate   float64 // tokens per segon
	lastRefill time.Time
}

func newTokenBucket(rate, burst float64) *tokenBucket {goCover_33ba7a78e32c__138[0] = 1 ; goCover_33ba7a78e32c__138[1] = goCover_33ba7a78e32c_P ; goCover_33ba7a78e32c__138[2] = 138 ; goCover_33ba7a78e32c__138[3]++;
	return &tokenBucket{
		tokens:     burst,
		capacity:   burst,
		fillRate:   rate,
		lastRefill: time.Now(),
	}
}

func (tb *tokenBucket) allow(n float64) bool {goCover_33ba7a78e32c__139[0] = 5 ; goCover_33ba7a78e32c__139[1] = goCover_33ba7a78e32c_P ; goCover_33ba7a78e32c__139[2] = 139 ; goCover_33ba7a78e32c__139[3]++;
	tb.mu.Lock()
	defer tb.mu.Unlock()

	now := time.Now()
	elapsed := now.Sub(tb.lastRefill).Seconds()
	tb.tokens += elapsed * tb.fillRate
	if tb.tokens > tb.capacity {goCover_33ba7a78e32c__139[6]++;
		tb.tokens = tb.capacity
	}
	goCover_33ba7a78e32c__139[4]++;tb.lastRefill = now

	if tb.tokens >= n {goCover_33ba7a78e32c__139[7]++;
		tb.tokens -= n
		return true
	}
	goCover_33ba7a78e32c__139[5]++;return false
}

// Gestor global de buckets per clau (ruta + IP o sessió)
var bucketRegistry = struct {
	mu      sync.Mutex
	buckets map[string]*tokenBucket
}{
	buckets: make(map[string]*tokenBucket),
}

type routeLimitConfig struct {
	rate  float64 // tokens/segon
	burst float64 // capacitat
}

// Config per ruta (prefix). Default si no hi ha match.
var routeLimits = map[string]routeLimitConfig{
	"/static/":  {rate: 20, burst: 30}, // permet descarregar molts recursos en carregar pàgina
	"/login":    {rate: 5, burst: 10},  // una mica més estricte
	"/registre": {rate: 2, burst: 5},   // molt estricte per prevenir abús
}

var defaultRouteLimit = routeLimitConfig{rate: 10, burst: 20}

func getRouteLimit(path string) routeLimitConfig {goCover_33ba7a78e32c__140[0] = 4 ; goCover_33ba7a78e32c__140[1] = goCover_33ba7a78e32c_P ; goCover_33ba7a78e32c__140[2] = 140 ; goCover_33ba7a78e32c__140[3]++;
	for prefix, cfg := range routeLimits {goCover_33ba7a78e32c__140[5]++;
		if strings.HasPrefix(path, prefix) {goCover_33ba7a78e32c__140[6]++;
			return cfg
		}
	}
	goCover_33ba7a78e32c__140[4]++;return defaultRouteLimit
}

// retorna una clau de limitació basada en ruta + sessió (si disponible) o IP
func getRequesterKey(r *http.Request, route string) string {goCover_33ba7a78e32c__141[0] = 3 ; goCover_33ba7a78e32c__141[1] = goCover_33ba7a78e32c_P ; goCover_33ba7a78e32c__141[2] = 141 ; goCover_33ba7a78e32c__141[3]++;
	if sid := getSessionID(r); sid != "" {goCover_33ba7a78e32c__141[5]++;
		return route + "::SID::" + sid
	}
	goCover_33ba7a78e32c__141[4]++;return route + "::IP::" + getIP(r)
}

// intenta obtenir algun identificador de sessió/cookie existent
func getSessionID(r *http.Request) string {goCover_33ba7a78e32c__142[0] = 4 ; goCover_33ba7a78e32c__142[1] = goCover_33ba7a78e32c_P ; goCover_33ba7a78e32c__142[2] = 142 ; goCover_33ba7a78e32c__142[3]++;
	// Cerca cookies comunes; si el projecte defineix una altra, s'afegeix aquí
	candidateNames := []string{"cg_session", "session_id", "sid", "SESSION"}
	for _, name := range candidateNames {goCover_33ba7a78e32c__142[5]++;
		if c, err := r.Cookie(name); err == nil && c != nil && c.Value != "" {goCover_33ba7a78e32c__142[6]++;
			return c.Value
		}
	}
	goCover_33ba7a78e32c__142[4]++;return ""
}

/*func applyMiddleware(fn http.HandlerFunc, middlewares ...func(http.HandlerFunc) http.HandlerFunc) http.HandlerFunc {
	for _, mw := range middlewares {
		fn = mw(fn)
	}
	return fn
}*/

// blockIPs – Bloqueja accés per IP o rang d'IPs
func BlockIPs(next http.HandlerFunc) http.HandlerFunc {goCover_33ba7a78e32c__143[0] = 5 ; goCover_33ba7a78e32c__143[1] = goCover_33ba7a78e32c_P ; goCover_33ba7a78e32c__143[2] = 143 ; goCover_33ba7a78e32c__143[3]++;
	return func(w http.ResponseWriter, r *http.Request) {goCover_33ba7a78e32c__143[4]++;
		ipStr := getIP(r)

		blockedIps := strings.Split(cnf.Config["BLOCKED_IPS"], ",")
		for _, b := range blockedIps {goCover_33ba7a78e32c__143[6]++;
			if ipStr == b {goCover_33ba7a78e32c__143[7]++;
				Errorf("Accés denegat per IP bloquejada: %s", ipStr)
				http.Error(w, "Accés denegat", http.StatusForbidden)
				return
			}
		}

		goCover_33ba7a78e32c__143[5]++;next(w, r)
	}
}

// rateLimit – Permet una petició cada 100ms (10 peticions/segon com a màxim)
func RateLimit(next http.HandlerFunc) http.HandlerFunc {goCover_33ba7a78e32c__144[0] = 6 ; goCover_33ba7a78e32c__144[1] = goCover_33ba7a78e32c_P ; goCover_33ba7a78e32c__144[2] = 144 ; goCover_33ba7a78e32c__144[3]++;
	return func(w http.ResponseWriter, r *http.Request) {goCover_33ba7a78e32c__144[4]++;
		path := r.URL.Path
		cfg := getRouteLimit(path)
		key := getRequesterKey(r, path)

		bucketRegistry.mu.Lock()
		b, ok := bucketRegistry.buckets[key]
		if !ok {goCover_33ba7a78e32c__144[7]++;
			b = newTokenBucket(cfg.rate, cfg.burst)
			bucketRegistry.buckets[key] = b
		}
		goCover_33ba7a78e32c__144[5]++;bucketRegistry.mu.Unlock()

		if !b.allow(1) {goCover_33ba7a78e32c__144[8]++;
			ipStr := getIP(r)
			Errorf("Massa peticions (path=%s, key=%s, ip=%s)", path, key, ipStr)
			http.Error(w, "Massa peticions", http.StatusTooManyRequests)
			return
		}

		goCover_33ba7a78e32c__144[6]++;next(w, r)
	}
}

// serveStatic – Serveix només recursos autoritzats
func ServeStatic(w http.ResponseWriter, r *http.Request) {goCover_33ba7a78e32c__145[0] = 27 ; goCover_33ba7a78e32c__145[1] = goCover_33ba7a78e32c_P ; goCover_33ba7a78e32c__145[2] = 145 ; goCover_33ba7a78e32c__145[3]++;
	path := r.URL.Path[len("/static/"):]
	realPath := filepath.Join("static", path)

	// Bloqueja Path Traversal
	if strings.Contains(path, "..") || strings.HasPrefix(path, "/") {goCover_33ba7a78e32c__145[10]++;
		Errorf("Intent de path traversal: %s", realPath)
		http.Error(w, "Accés denegat", http.StatusForbidden)
		return
	}

	// No permet llistar carpetes
	goCover_33ba7a78e32c__145[4]++;info, err := os.Stat(realPath)
	if err == nil && info.IsDir() {goCover_33ba7a78e32c__145[11]++;
		ipStr := strings.Split(r.RemoteAddr, ":")[0]
		Errorf("Intent de llistar carpeta: %s - IP: %s", realPath, ipStr)
		http.Error(w, "Accés denegat", http.StatusForbidden)
		return
	}

	// Si no existeix
	goCover_33ba7a78e32c__145[5]++;if _, err := os.Stat(realPath); os.IsNotExist(err) {goCover_33ba7a78e32c__145[12]++;
		// Fallback: si l'executable s'executa fora de l'arrel, prova ruta relativa al fitxer actual
		if _, file, _, ok := runtime.Caller(0); ok {goCover_33ba7a78e32c__145[13]++;
			altBase := filepath.Join(filepath.Dir(file), "..")
			altPath := filepath.Join(altBase, "static", path)
			if _, err2 := os.Stat(altPath); err2 == nil {goCover_33ba7a78e32c__145[14]++;
				realPath = altPath
			} else{ goCover_33ba7a78e32c__145[15]++;{
				http.Error(w, "Fitxer no trobat", http.StatusNotFound)
				return
			}}
		} else{ goCover_33ba7a78e32c__145[16]++;{
			http.Error(w, "Fitxer no trobat", http.StatusNotFound)
			return
		}}
	}

	// Verifica si el camí està autoritzat
	goCover_33ba7a78e32c__145[6]++;allowed := allowedFiles[path] ||
		strings.HasPrefix(path, "css/") ||
		strings.HasPrefix(path, "js/") ||
		strings.HasPrefix(path, "img/") ||
		strings.HasPrefix(path, "fonts/")
	if !allowed {goCover_33ba7a78e32c__145[17]++;
		Errorf("Fitxer no autoritzat: %s", path)
		http.Error(w, "Aquest recurs no es pot servir", http.StatusForbidden)
		return
	}

	// Obtenir IP netament
	goCover_33ba7a78e32c__145[7]++;ipStr := getIP(r)

	// Aplica Content-Type manualment
	ext := strings.ToLower(filepath.Ext(path))
	switch ext {
	case ".js":goCover_33ba7a78e32c__145[18]++;
		w.Header().Set("Content-Type", "application/javascript; charset=utf-8")
	case ".css":goCover_33ba7a78e32c__145[19]++;
		w.Header().Set("Content-Type", "text/css; charset=utf-8")
	case ".png":goCover_33ba7a78e32c__145[20]++;
		w.Header().Set("Content-Type", "image/png")
	case ".jpg", ".jpeg":goCover_33ba7a78e32c__145[21]++;
		w.Header().Set("Content-Type", "image/jpeg")
	case ".gif":goCover_33ba7a78e32c__145[22]++;
		w.Header().Set("Content-Type", "image/gif")
	case ".svg":goCover_33ba7a78e32c__145[23]++;
		w.Header().Set("Content-Type", "image/svg+xml")
	case ".ico":goCover_33ba7a78e32c__145[24]++;
		w.Header().Set("Content-Type", "image/x-icon")
	default:goCover_33ba7a78e32c__145[25]++;
		// Deixa que Go dedueixi el Content-Type automàticament per altres tipus
		if ext != ".html" {goCover_33ba7a78e32c__145[26]++;
			Errorf("Extensió no permesa: %s", ext)
			http.Error(w, "Tipus de fitxer no suportat", http.StatusForbidden)
			return
		}
	}

	// Aplica referer check només per JS/CSS
	goCover_33ba7a78e32c__145[8]++;if strings.HasSuffix(path, ".js") || strings.HasSuffix(path, ".css") {goCover_33ba7a78e32c__145[27]++;
		referer := r.Header.Get("Referer")
		if referer != "" {goCover_33ba7a78e32c__145[28]++;
			if !strings.HasPrefix(referer, "http://localhost") && !strings.HasPrefix(referer, "https://genealogia.cat") {goCover_33ba7a78e32c__145[29]++;
				Errorf("Accés amb referer invàlid: %s - IP: %s", referer, ipStr)
				http.Error(w, "Accés denegat", http.StatusForbidden)
				return
			}
		}
	}

	// Serveix el fitxer
	goCover_33ba7a78e32c__145[9]++;http.ServeFile(w, r, realPath)
}

// SecureHeadersMiddleware – Aplica headers de seguretat a totes les rutes
func SecureHeaders(next http.HandlerFunc) http.HandlerFunc {goCover_33ba7a78e32c__146[0] = 13 ; goCover_33ba7a78e32c__146[1] = goCover_33ba7a78e32c_P ; goCover_33ba7a78e32c__146[2] = 146 ; goCover_33ba7a78e32c__146[3]++;
	return func(w http.ResponseWriter, r *http.Request) {goCover_33ba7a78e32c__146[4]++;
		// Content Security Policy
		w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self' https://cdnjs.cloudflare.com ; style-src 'self' 'unsafe-inline'; img-src 'self'; font-src 'self'; connect-src 'self';")
		//w.Header().Set("Content-Security-Policy", "frame-ancestors 'none'")

		// HSTS - Força HTTPS
		if os.Getenv("ENVIRONMENT") != "development" {goCover_33ba7a78e32c__146[10]++;
			w.Header().Set("Strict-Transport-Security", "max-age=63072000; includeSubDomains; preload")
		}

		// Protecció XSS
		goCover_33ba7a78e32c__146[5]++;w.Header().Set("X-XSS-Protection", "1; mode=block")

		// MIME Sniffing - Només en producció per evitar problemes en desenvolupament
		if os.Getenv("ENVIRONMENT") != "development" {goCover_33ba7a78e32c__146[11]++;
			w.Header().Set("X-Content-Type-Options", "nosniff")
		}

		// Evita que la web s'incrusti en altres webs
		goCover_33ba7a78e32c__146[6]++;w.Header().Set("X-Frame-Options", "DENY")

		// CORS
		w.Header().Set("Access-Control-Allow-Origin", "https://genealogia.cat ")
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Accept, Content-Type, Authorization")

		// Restringeix el Referer per seguretat: envia l'origen (domini) en peticions cross-origin, evitant filtrar URLs completes.
		w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")

		// Només quan volem que els cercadors no ens indexin
		w.Header().Set("X-Robots-Tag", "noindex, nofollow, nosnippet, noarchive")

		ipStr := strings.Split(r.RemoteAddr, ":")[0]

		// Bloqueja User-Agent sospitosos
		userAgent := r.UserAgent()
		for _, agent := range blockedUserAgents {goCover_33ba7a78e32c__146[12]++;
			if strings.Contains(userAgent, agent) {goCover_33ba7a78e32c__146[13]++;
				Errorf("Scraper bloquejat: %s - IP: %s", userAgent, ipStr)
				http.Error(w, "Accés denegat", http.StatusForbidden)
				return
			}
		}

		// Referer check només per JS/CSS
		goCover_33ba7a78e32c__146[7]++;referer := r.Header.Get("Referer")
		if referer != "" && !strings.HasPrefix(referer, "http://localhost") && !strings.HasPrefix(referer, "https://genealogia.cat ") {goCover_33ba7a78e32c__146[14]++;
			Errorf("Accés amb referer invàlid: %s - IP: %s", referer, ipStr)
			http.Error(w, "Accés denegat", http.StatusForbidden)
			return
		}

		// Força HTTPS en producció
		goCover_33ba7a78e32c__146[8]++;if r.URL.Scheme != "https" && os.Getenv("ENVIRONMENT") != "development" {goCover_33ba7a78e32c__146[15]++;
			Infof("Redirigint a HTTPS: %s", r.Host+r.URL.Path)
			http.Redirect(w, r, "https://"+r.Host+r.URL.Path, http.StatusMovedPermanently)
			return
		}

		goCover_33ba7a78e32c__146[9]++;next(w, r)
	}
}

// InitWebServer – Carrega configuració de seguretat i inicia el servidor
func InitWebServer(cfg map[string]string) {goCover_33ba7a78e32c__147[0] = 2 ; goCover_33ba7a78e32c__147[1] = goCover_33ba7a78e32c_P ; goCover_33ba7a78e32c__147[2] = 147 ; goCover_33ba7a78e32c__147[3]++;
	Infof("Iniciant servidor amb mesures de seguretat...")
	if cfg != nil {goCover_33ba7a78e32c__147[4]++;
		cnf.Config = cfg
	}
}

func IsBlocked(ip string) bool {goCover_33ba7a78e32c__148[0] = 4 ; goCover_33ba7a78e32c__148[1] = goCover_33ba7a78e32c_P ; goCover_33ba7a78e32c__148[2] = 148 ; goCover_33ba7a78e32c__148[3]++;
	blockedIps := strings.Split(cnf.Config["BLOCKED_IPS"], ",")
	for _, b := range blockedIps {goCover_33ba7a78e32c__148[5]++;
		if ip == b {goCover_33ba7a78e32c__148[6]++;
			return true
		}
	}
	goCover_33ba7a78e32c__148[4]++;return false
}

func ApplyRateLimit(ip string) bool {goCover_33ba7a78e32c__149[0] = 3 ; goCover_33ba7a78e32c__149[1] = goCover_33ba7a78e32c_P ; goCover_33ba7a78e32c__149[2] = 149 ; goCover_33ba7a78e32c__149[3]++;
	// Útil per a punts sense *http.Request: aplicació d'un límit genèric per IP
	cfg := defaultRouteLimit
	key := "/generic" + "::IP::" + ip

	bucketRegistry.mu.Lock()
	b, ok := bucketRegistry.buckets[key]
	if !ok {goCover_33ba7a78e32c__149[5]++;
		b = newTokenBucket(cfg.rate, cfg.burst)
		bucketRegistry.buckets[key] = b
	}
	goCover_33ba7a78e32c__149[4]++;bucketRegistry.mu.Unlock()

	return b.allow(1)
}

func getIP(r *http.Request) string {goCover_33ba7a78e32c__150[0] = 10 ; goCover_33ba7a78e32c__150[1] = goCover_33ba7a78e32c_P ; goCover_33ba7a78e32c__150[2] = 150 ; goCover_33ba7a78e32c__150[3]++;
	Debugf("[getIP] RemoteAddr rebut: %v", r.RemoteAddr)
	forwarded := r.Header.Get("X-Forwarded-For")
	if forwarded != "" {goCover_33ba7a78e32c__150[7]++;
		Debugf("[getIP] X-Forwarded-For: %v", forwarded)
		ip := strings.Split(forwarded, ",")[0]
		Debugf("[getIP] IP parsejada de X-Forwarded-For: %v", ip)
		return ip
	}
	goCover_33ba7a78e32c__150[4]++;realIP := r.Header.Get("X-Real-IP")
	if realIP != "" {goCover_33ba7a78e32c__150[8]++;
		Debugf("[getIP] X-Real-IP: %v", realIP)
		return realIP
	}

	// Manejar IPv6 correctament
	goCover_33ba7a78e32c__150[5]++;ipPort := r.RemoteAddr
	var ip string
	if strings.Contains(ipPort, "[") {goCover_33ba7a78e32c__150[9]++;
		// IPv6 format: [::1]:port
		start := strings.Index(ipPort, "[")
		end := strings.Index(ipPort, "]")
		if start != -1 && end != -1 {goCover_33ba7a78e32c__150[10]++;
			ip = ipPort[start+1 : end]
		} else{ goCover_33ba7a78e32c__150[11]++;{
			ip = ipPort
		}}
	} else{ goCover_33ba7a78e32c__150[12]++;{
		// IPv4 format: 127.0.0.1:port
		ip = strings.Split(ipPort, ":")[0]
	}}
	goCover_33ba7a78e32c__150[6]++;Debugf("[getIP] IP parsejada de RemoteAddr: %v", ip)
	return ip
}
